<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>RenderState 类 | Qt Quick 5.12.3</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtquick-index.html">Qt Quick 模块</a></td><td ><a href="qtquick-module.html">C++ 类</a></td><td >RenderState</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right"><a href="qtquick-index.html">Qt 5.12.3 参考指南</a></td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#public-functions">公用函数</a></li>
<li class="level1"><a href="#details">详细信息</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">RenderState 类</h1>
<span class="small-subtitle">(<a href="qsgrendernode-renderstate.html">QSGRenderNode::RenderState</a>)<br/></span>
<ul>
<li><a href="qsgrendernode-renderstate-members.html">所有成员的列表，包括继承成员</a></li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions">公用函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual const QRegion *</td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode-renderstate.html#clipRegion">clipRegion</a></b>() const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void *</td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode-renderstate.html#get">get</a></b>(const char *<i>state</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual const QMatrix4x4 *</td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode-renderstate.html#projectionMatrix">projectionMatrix</a></b>() const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode-renderstate.html#scissorEnabled">scissorEnabled</a></b>() const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRect </td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode-renderstate.html#scissorRect">scissorRect</a></b>() const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode-renderstate.html#stencilEnabled">stencilEnabled</a></b>() const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual int </td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode-renderstate.html#stencilValue">stencilValue</a></b>() const = 0</td></tr>
</table></div>
<a name="details"></a>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$clipRegion[overload1]$$$clipRegion -->
<h3 class="fn" id="clipRegion"><a name="clipRegion"></a><code>[pure virtual] </code>const <span class="type"><a href="../qtgui/qregion.html">QRegion</a></span> *RenderState::<span class="name">clipRegion</span>() const</h3>
<p>Returns the current clip region or null for backends where clipping is implemented via stencil or scissoring.</p>
<p>The software backend uses no projection, scissor or stencil, meaning most of the render state is not in use. However, the clip region that can be set on the <a href="../qtgui/qpainter.html">QPainter</a> still has to be communicated since reconstructing this manually in <a href="qsgrendernode.html#render">render</a>() is not reasonable. It can therefore be queried via this function. The region is in world coordinates and can be passed to <a href="../qtgui/qpainter.html#setClipRegion">QPainter::setClipRegion</a>() with <a href="../qtcore/qt.html#ClipOperation-enum">Qt::ReplaceClip</a>. This must be done before calling <a href="../qtgui/qpainter.html#setTransform">QPainter::setTransform</a>() since the clip region is already mapped to the transform provided in <a href="qsgrendernode.html#matrix">QSGRenderNode::matrix</a>().</p>
<!-- @@@clipRegion -->
<!-- $$$get[overload1]$$$getconstchar* -->
<h3 class="fn" id="get"><a name="get"></a><code>[virtual] </code><span class="type">void</span> *RenderState::<span class="name">get</span>(const <span class="type">char</span> *<i>state</i>) const</h3>
<p>Returns pointer to a <i>state</i> value.</p>
<p>Reserved for future use.</p>
<!-- @@@get -->
<!-- $$$projectionMatrix[overload1]$$$projectionMatrix -->
<h3 class="fn" id="projectionMatrix"><a name="projectionMatrix"></a><code>[pure virtual] </code>const <span class="type"><a href="../qtgui/qmatrix4x4.html">QMatrix4x4</a></span> *RenderState::<span class="name">projectionMatrix</span>() const</h3>
<p>Returns pointer to the current projection matrix.</p>
<p>The model-view matrix can be retrieved with <a href="qsgrendernode.html#matrix">QSGRenderNode::matrix</a>(). Typically <code>projection * modelview</code> is the matrix that is then used in the vertex shader to transform the vertices.</p>
<!-- @@@projectionMatrix -->
<!-- $$$scissorEnabled[overload1]$$$scissorEnabled -->
<h3 class="fn" id="scissorEnabled"><a name="scissorEnabled"></a><code>[pure virtual] </code><span class="type">bool</span> RenderState::<span class="name">scissorEnabled</span>() const</h3>
<p>Returns the current state of scissoring.</p>
<p><b>Note: </b>Only relevant for graphics APIs that have a dedicated on/off state of scissoring.</p><!-- @@@scissorEnabled -->
<!-- $$$scissorRect[overload1]$$$scissorRect -->
<h3 class="fn" id="scissorRect"><a name="scissorRect"></a><code>[pure virtual] </code><span class="type"><a href="../qtcore/qrect.html">QRect</a></span> RenderState::<span class="name">scissorRect</span>() const</h3>
<p>Returns the current scissor rectangle when clipping is active.</p>
<p><b>Note: </b>Be aware of the differences between graphics APIs: for some the scissor rect is only active when scissoring is enabled (for example, OpenGL), while for others the scissor rect is equal to the viewport rect when there is no need to scissor away anything (for example, Direct3D 12).</p><!-- @@@scissorRect -->
<!-- $$$stencilEnabled[overload1]$$$stencilEnabled -->
<h3 class="fn" id="stencilEnabled"><a name="stencilEnabled"></a><code>[pure virtual] </code><span class="type">bool</span> RenderState::<span class="name">stencilEnabled</span>() const</h3>
<p>Returns the current state of stencil testing.</p>
<p><b>Note: </b>With graphics APIs where stencil testing is enabled in pipeline state objects, instead of individual state-setting commands, it is up to the implementation of <a href="qsgrendernode.html#render">render</a>() to enable stencil testing with operations <code>KEEP</code>, comparison function <code>EQUAL</code>, and a read and write mask of <code>0xFF</code>.</p><!-- @@@stencilEnabled -->
<!-- $$$stencilValue[overload1]$$$stencilValue -->
<h3 class="fn" id="stencilValue"><a name="stencilValue"></a><code>[pure virtual] </code><span class="type">int</span> RenderState::<span class="name">stencilValue</span>() const</h3>
<p>Returns the current stencil reference value when clipping is active.</p>
<!-- @@@stencilValue -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2019 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
